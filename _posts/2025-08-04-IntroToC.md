---
title: CS 8001 OIC - Introduction to C seminar
date: 2025-08-04 16:38:00 +0800
categories: [GaTech OMSCS, Introduction to C]
tags: [c]     # TAG names should always be lowercase
description: Overview & Projects from the Introduction to C Seminar 
---


# Welcome


## Individual Project: PSI Lisp Interpreter in C
### Functionality 
My Lisp interpreter takes an input in the terminal from a user and returns a computation. It takes in numbers, booleans, symbols, lists, functions, definitions, heads/tails/cons, quotes (WIP), strings, inputs/outputs, and types. Examples below: 
```c
psi> (+)
0
psi> (+ 5 6 7)
18
psi> (= 3 3 4)
#f
psi> (< 3 4 5)
#t
psi> (not #t)
#f
psi> (not 1)
#f
psi> (not #f)
#t
psi> (= 0 ()) 
#f
psi> (!= 0 ())
#t
psi> (def a 7) 
7
psi> a
7
psi> (+ a 4)
11
psi> (def a (+ a 6)) 
13
psi>  (+ a 4) 
17
psi> (+ 3 4) 
7
psi> (/ 1 0)
$error{(Divide by zero)}
Evaluation failed.
psi> (+ _ 1)
8
psi> (def l (cons 1 (cons 2 ())))
(1 2)
psi> (head l)
1
psi> (tail l)
(2)
psi> (quote x)
x
psi> 'x
x
psi> "cat"
"cat"
psi> (ord "cat")
(99 97 116)
psi> (input)
hello
"hello"
psi> (output "Hello\n\nworld!\n")        
Hello\n\nworld!\n
#t
psi> (type #t)
bool
psi> (type 1)
num
```
### Psuedocode
See Github repo for full code 
My PSI interpreter is structured in the following sections described below, header, tokenizer, parser, evaluator, printer, REPL & file reader. 
- In the header, I started with the preprocessor directives that include the contents of relevant standard C library headers for functions, booleans, and string manipulation. The macros are defined and the enumerated types for the tokenizer and nodes (for the Abstract Tree Syntax) are structured. I use two structs for the AST itself and the binding needed for call backs with special forms like ‘def’ and ‘_’. The struct defining the AST is set up with a union (labeled ast). I defined the struct as Node, then I called on the NodeType enum defined right above it; I started slotting the behavior based on what Node type I was dealing with (NODE_NUM identifying numbers, NODE_BOOL identifying booleans, etc). I used a union to hold all of the different identifiers I needed to categorize within the Node Type identified in the REPL, for example if the type is a string literal (i.e NODE_STRING) then the strVal member is used. I have two structs inside of the union - defining function and list, so - ideally - the functionality needed for the entirety of the interpreter was structured in a clear/understandable format. If I needed to point to the argument count in the function of NODE_FUNCTION, I simply point to ast.function.argCount[i] or if I need to point to the head of a head/tails/cons, I point to ast.list.head, I was thinking of it like folders and subfolders holding information as a way to wrap my head around it.
- In the tokenizer - the function reads in the globals and forward declarations in the header and starts on a looping if/else if through every type of value/type/string/function /special declaration defined in the interpreter. All inputs are defined as a number/boolean/left or right parenthesis/symbol/list/function/definition/quote/string/error to start the organizing process of defining what to do with the user's input. I used the isop helper function to distinguish between a symbol/list/function at the tokenizer stage. The tokenize function takes the input from the readToken function and iterates through the array to make sure the ‘currentType’ variable (current identified token type) is stored. PrintTokens is used as a debugger to ensure the tokens are being assigned as intended. 
- In the parser - I used recursive descent parsing to implement the correct grammar rules for the AST. I broke up my parser into two main functions: parse_args(), and parse_expr(). Starting in reverse order with parse_expr, this is the meat of the entire interpreter. I ran through each token type identified from the tokenizer, assigning and constructing the AST nodes. Using dynamic memory allocation and memory free-ing at each step, I started to build the link between the tokenizer and the header struct Node. If the current token was, for example, Tok_NUM (representative of a number), the node type is assigned to NODE_NUM (node->type = NODE_NUM) and the respective union parameter (in this case intVal, representing integer value) was identified. This logic was identified for numbers, booleans, quotes, strings to ensure that functionality outside of the Lisp dialect is supported; an example being the string input psi>“cat” returns “cat” without need for parenthesis. All Lisp specific functionality exists within an if statement defining that the open parenthesis must be present in order to continue. This conditional creates a clear separation between the Lisp specific and common functionality of the parser.
- In the evaluator - For numbers, booleans, and lists, I return ‘node’, calling the REPL input provided by the user. For def and symbol, the binded value stored in the array ‘Binded’ is called using bind_number() and printed in the terminal. For Lisp functionality, it all falls into NODE_FUNCTION, the open parentheses ‘(‘ is skipped and the operators/special forms are identified with if/else if statements using strcmp as a matching conditional. Inside of NODE_FUNCTION, the following forms are evaluated in the expected Lisp format in this order: singular operands (+)/(*), _, input, output, =, !=, head, tails, cons, not, if, ord, chr, type, +,-, *, /, >,<,>=,<=. 
- In the REPL/File Reader - the printing capability and caveman debugging strategies exist are critical to this section of code. I broke up the sections into print_node_repr(), and main(). Print_node_repr() is a helper function for main, describing what should be printed based on the node type.

## Individual Project - Stackman 

See Github repo for full code 

*TBD* will add pseudocode here

## Individual Assignments  
All answers on Github private repo

### Assignment 1 
General questions about semester expectations
### Assignment 2
Investigate the following loop - what do you think it does? 
```c
unsigned int i = 1;
while (i > 0) {
    i++;
}
```
### Assignment 3 
3.1: Read the documentation on strcpy and strncpy. What is the main difference between these functions? Why might you use one and not the other?

3.2: Is this legal code? Why or why not? What does it do?
```c
void mystery(char* x) {
  while (*x) {
      if (*x > 96) *x -= 32;
      x++;
  }
}
```
3.3: Compile and run this program:
```c
#include "stdio.h"

void print_size(int a[]) {
    printf("sizeof(a) = %lu\n", sizeof(a));
}

int main(int argc, char** argv) {
    int a[7];
    printf("sizeof(a) = %lu\n", sizeof(a));
    print_size(a);
    return 0;
}
```
What does it do? Why does it give different sizeof values in different places?

Week 3 Project

Create a command line utility that tabulates the letters in all words (which do not have to be valid English words) supplied as arguments and prints out the number of each letter in the whole list. All words will be in lower-case ASCII letters, of length 1 to 128, and there will be no more than 255 of them. Example usages:

 
```c
$ ./tabulate

$ ./tabulate bat cat dog
A 2 
B 1 
C 1 
D 1
G 1
O 1
T 2
$ ./tabulate aaaa bxvr corn dzqwrqnx
A 4
B 1
C 1
D 1
N 2
O 1
Q 2
R 3
V 1
W 1
X 2
Z 1
```

### Assignment 4 
4.1: Investigate the functions calloc, realloc, and alloca. Why does calloc have the type
signature it does? Why is realloc useful? How does alloca differ from malloc and why is it
rarely used?

4.2: Consider the following program:
```c
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
int64_t recur_sum(int64_t n) {
    if (n <= 0)
        return 0;
    else
        return n + recur_sum(n-1);
}
int main(int argc, char** argv) {
    int64_t n = 100;
    if (argc > 1)
        n = atoll(argv[1]);
    printf("%lld\n", recur_sum(n));
}
```
Ignore integer overflow—assume the argument provided will never exceed 1 billion; in this case,
it will never occur.
Is this a legal program? Is it good practice? What happens if 10000000 is supplied at the
command line? Why?
4.3: Could this method, from above:
```c
void person_delete(person* this) {
    free(this->name);
    free(this);
}
```
be rewritten with the order of the frees reversed? Why or why not?
### Assignment 5 
5.1: Why do we need to do the putchar loop in bytestring_print_ascii? Why can't we replace the entire loop:
```c
for (int i = 0; i < b->length; i++) {
    putchar(b->data[i]);
}
```
with
```c
printf("%s", b->data)
```
? More specifically, what input might cause the latter to fail?

5.2: Consider an alternate data structure to represent dyn_value:
```c
const int DBool = 0;
const int DNumber = 1;
const int DString = 2;   // same as above

typedef struct dyn_value_2 {
    int     type;
    bool    as_bool;
    double  as_number;
    bytestring* as_string;
} dyn_value_2;
```
How would one use this data structure, instead of the void* based one? Is it legal to do this? What advantages does it have? What disadvantages does it have?

5.3: Run your StackMan implementation on the six tests (test_1.sm, ..., test_6.sm) supplied in Canvas under Files. Some of these will terminate normally; others will generate errors (i.e., they are not valid StackMan programs when executed against an empty stack.) None of them loop indefinitely (although that is possible in StackMan.) In the case of successful execution, tell me what the stack contents are after successful execution as well as the instruction count. For example:
```c
test_1.sm
# instructions: 40
final stack contents: 2 0 2 5
```
In an error case, tell me which error is produced.

Hint: 166 is a common wrong answer for test_5.sm. If you get this, it probably means you implemented looping as a do-while loop rather than a while loop.

For test_5.sm and test_6.sm, I also want you to tell me how long your implementation takes. You are not graded (so long as your programs do terminate) on performance; the lesson here is to observe and report. Use the Unix time utility or something similar if available; if not, stopwatch time is acceptable.

5.4: Include your StackMan implementation code on subsequent pages.

### Assignment 6 
6.1 Does replacing gets with fgets as above fix all security issues in main in Module 6 (pp. 1-2)? Why or why not?

6.2. An often-seen formulation of int_compar in Module 6 is:
```c
int int_compar(const void *p1, const void *p2) {
  int x1 = *((const int *) p1);
  int x2 = *((const int *) p2);

  return x1 - x2;
}
```
It seems like this might be better, insofar as it uses one operation and no branching, as opposed to two comparisons. Why isn't it?

6.3. Pick any high-level language you've used for any project of appreciable size. Tell me something you think the runtime uses function pointers for, and why. What do you believe is gained, and what is lost, due to this decision? You don't have to be right; just give me your best guess.

6.4. Predict what this program will do. (You will not be graded on the correctness of your prediction.) Then run it. Was your prediction correct? Why or why not?
```c
#include <inttypes.h>
#include <stdio.h>

int main () {
    uint8_t a = 37;
    uint8_t b = 38;
    int c = (int) (uint8_t) (a - b);
    int d = (int) (a - b);

    if (c == d) {
        printf("equal\n");
    } else {
        printf("not equal\n");
    }

    return 0;
}
```

### Assignment 7 
This assignment pertains to Module 7.

7.1. Should the second malloc (line 6) of res_array_new be replaced with calloc? Why or why not?

7.2. Write a method, like res_array_push, that prepends to the resizable array—that is, that puts the newly placed element at index 0. Why would you prefer to rarely use this?

7.3. (This question is ungraded. Any submission on time will receive full credit.) Is there anything that has not been covered that you would like to see? If you have no suggestions, feel free to leave this blank.

### Assignment 8 
8.1. A generic (typeless) hashtable could be built using void* as its key type. In this case, you could use the identity hash function—the pointer’s address is its hash value. Is this a good choice? Why or why not?

8.2. To avoid wasting space, might it be a good idea to set downsize_threshold to 0.5? What change could be made to the implementation to make this a sound thing to do?

### Assignment 9 
Seven humanoid robots with “names” (or IDs) 0, 1, 2, ... , 6 are playing a cooperative video game around a circular table with seven joysticks, each sitting between two of them—for example, Robot #0 can reach Joystick #0 with his left arm and Joystick #1 with his right arm; Robot #1 can reach Joystick #1 with her left arm and Joystick #2 with her right arm. The game can only be effectively played by a robot using two joysticks at a time, but they can only win if all of them contribute. They are all programmed like so (in pseudocode):
```
.loop:
  1. Wait 0-300 seconds (random interval).
  2. Grab joystick with left arm, or wait to do so.
  3. Grab joystick with right arm, or wait to do so.
  4. Play for 0-300 seconds (random interval).
  5. Goto .loop
  ```
Why is this a bad design? How would you fix it?


## Resources

### Text Books
[1] https://beej.us/guide/bgc/pdf/bgc_usl_c_1.pdf
### Github Repo (private)

### Online materials
[2] https://omscs.gatech.edu/cs-8001-seminars

## What I'm doing next
