---
title: CS 8001 OIC - Introduction to C seminar
date: 2025-08-04 16:38:00 +0800
categories: [GaTech OMSCS, Introduction to C]
tags: [c]     # TAG names should always be lowercase
description: Overview & Projects from the Introduction to C Seminar 
---


# Welcome
#### Note
For all OMSCS courses - I will provide pseudocode and video links, but I need to keep code in a private repository to uphold the honor code, descriptions, notes, etc are below.

## Individual Project: PSI Lisp Interpreter in C
### Functionality 
My Lisp interpreter takes an input in the terminal from a user and returns a computation. It takes in numbers, booleans, symbols, lists, functions, definitions, heads/tails/cons, quotes (WIP), strings, inputs/outputs, and types. Examples below: 
```c
psi> (+)
0
psi> (+ 5 6 7)
18
psi> (= 3 3 4)
#f
psi> (< 3 4 5)
#t
psi> (not #t)
#f
psi> (not 1)
#f
psi> (not #f)
#t
psi> (= 0 ()) 
#f
psi> (!= 0 ())
#t
psi> (def a 7) 
7
psi> a
7
psi> (+ a 4)
11
psi> (def a (+ a 6)) 
13
psi>  (+ a 4) 
17
psi> (+ 3 4) 
7
psi> (/ 1 0)
$error{(Divide by zero)}
Evaluation failed.
psi> (+ _ 1)
8
psi> (def l (cons 1 (cons 2 ())))
(1 2)
psi> (head l)
1
psi> (tail l)
(2)
psi> (quote x)
x
psi> 'x
x
psi> "cat"
"cat"
psi> (ord "cat")
(99 97 116)
psi> (input)
hello
"hello"
psi> (output "Hello\n\nworld!\n")        
Hello\n\nworld!\n
#t
psi> (type #t)
bool
psi> (type 1)
num
```
### Psuedocode
See Github repo for full code 
My PSI interpreter is structured in the following sections described below, header, tokenizer, parser, evaluator, printer, REPL & file reader. 
- In the header, I started with the preprocessor directives that include the contents of relevant standard C library headers for functions, booleans, and string manipulation. The macros are defined and the enumerated types for the tokenizer and nodes (for the Abstract Tree Syntax) are structured. I use two structs for the AST itself and the binding needed for call backs with special forms like ‘def’ and ‘_’. The struct defining the AST is set up with a union (labeled ast). I defined the struct as Node, then I called on the NodeType enum defined right above it; I started slotting the behavior based on what Node type I was dealing with (NODE_NUM identifying numbers, NODE_BOOL identifying booleans, etc). I used a union to hold all of the different identifiers I needed to categorize within the Node Type identified in the REPL, for example if the type is a string literal (i.e NODE_STRING) then the strVal member is used. I have two structs inside of the union - defining function and list, so - ideally - the functionality needed for the entirety of the interpreter was structured in a clear/understandable format. If I needed to point to the argument count in the function of NODE_FUNCTION, I simply point to ast.function.argCount[i] or if I need to point to the head of a head/tails/cons, I point to ast.list.head, I was thinking of it like folders and subfolders holding information as a way to wrap my head around it.
- In the tokenizer - the function reads in the globals and forward declarations in the header and starts on a looping if/else if through every type of value/type/string/function /special declaration defined in the interpreter. All inputs are defined as a number/boolean/left or right parenthesis/symbol/list/function/definition/quote/string/error to start the organizing process of defining what to do with the user's input. I used the isop helper function to distinguish between a symbol/list/function at the tokenizer stage. The tokenize function takes the input from the readToken function and iterates through the array to make sure the ‘currentType’ variable (current identified token type) is stored. PrintTokens is used as a debugger to ensure the tokens are being assigned as intended. 
- In the parser - I used recursive descent parsing to implement the correct grammar rules for the AST. I broke up my parser into two main functions: parse_args(), and parse_expr(). Starting in reverse order with parse_expr, this is the meat of the entire interpreter. I ran through each token type identified from the tokenizer, assigning and constructing the AST nodes. Using dynamic memory allocation and memory free-ing at each step, I started to build the link between the tokenizer and the header struct Node. If the current token was, for example, Tok_NUM (representative of a number), the node type is assigned to NODE_NUM (node->type = NODE_NUM) and the respective union parameter (in this case intVal, representing integer value) was identified. This logic was identified for numbers, booleans, quotes, strings to ensure that functionality outside of the Lisp dialect is supported; an example being the string input psi>“cat” returns “cat” without need for parenthesis. All Lisp specific functionality exists within an if statement defining that the open parenthesis must be present in order to continue. This conditional creates a clear separation between the Lisp specific and common functionality of the parser.
- In the evaluator - For numbers, booleans, and lists, I return ‘node’, calling the REPL input provided by the user. For def and symbol, the binded value stored in the array ‘Binded’ is called using bind_number() and printed in the terminal. For Lisp functionality, it all falls into NODE_FUNCTION, the open parentheses ‘(‘ is skipped and the operators/special forms are identified with if/else if statements using strcmp as a matching conditional. Inside of NODE_FUNCTION, the following forms are evaluated in the expected Lisp format in this order: singular operands (+)/(*), _, input, output, =, !=, head, tails, cons, not, if, ord, chr, type, +,-, *, /, >,<,>=,<=. 
- In the REPL/File Reader - the printing capability and caveman debugging strategies exist are critical to this section of code. I broke up the sections into print_node_repr(), and main(). Print_node_repr() is a helper function for main, describing what should be printed based on the node type.

## Individual Project - Stackman 

See Github repo for full code 

*TBD* will add pseudocode here

## Individual Assignments  
All answers on Github private repo

### Assignment 1 
General questions about semester expectations
### Assignment 2
This assignment investigates how unsigned integers behave when incremented beyond their maximum value. You analyze a loop that continually increases an unsigned integer until it overflows, wrapping back to zero. The focus is on understanding integer overflow, infinite loops, and how unsigned arithmetic differs from signed arithmetic in C.
### Assignment 3 
This assignment introduces pointer manipulation and memory layout in C. You analyze a function that transforms lowercase letters into uppercase, investigate why arrays behave differently when passed to functions, and then create a command-line tool that counts letter frequencies across multiple input words. The focus is on understanding strings, memory representation, and command-line argument handling.

### Assignment 4

This assignment explores memory allocation functions in C, including why calloc, realloc, and alloca behave differently and when each should be used. You then examine recursion with a summing function, discussing its legality, risks, and stack limitations when handling large input. Finally, you consider proper memory deallocation order in a custom struct to avoid errors or undefined behavior.

### Assignment 5

Here, you work with dynamic data structures and error handling. You compare different ways of printing raw data to highlight why null-terminated string assumptions can fail, explore an alternate type-tagged structure for representing dynamic values, and analyze trade-offs compared to void pointer approaches. The assignment ends with testing and debugging your implementation of the StackMan language, including measuring execution performance and reporting stack outcomes or errors.

### Assignment 6

This assignment focuses on security, comparison functions, and low-level behavior of C. You assess whether replacing unsafe functions with safer ones eliminates vulnerabilities, evaluate pitfalls in using subtraction-based comparators, and speculate about how higher-level languages use function pointers. Finally, you predict and explain subtle results from integer type conversions and signed vs. unsigned arithmetic.

### Assignment 7

This assignment explores memory allocation strategies in building resizable arrays. You consider whether initialization should use calloc, design a method to prepend elements at index 0, and discuss why such operations are inefficient. The emphasis is on reasoning about memory trade-offs and algorithmic complexity in dynamic data structures.

### Assignment 8

This assignment examines hashtable implementation choices. You analyze whether using raw pointer addresses as hash values is effective, and consider how resizing thresholds affect memory usage and performance. You propose modifications to make downsizing thresholds safe while balancing efficiency and space savings.

### Assignment 9

This assignment presents a concurrency and synchronization problem involving multiple robots sharing joysticks. You analyze why the given design leads to deadlock and starvation due to poor resource management. The task is to propose fixes, such as introducing ordering, resource hierarchies, or concurrency control mechanisms, to ensure all robots can contribute fairly.


## Resources

### Text Books
[1] https://beej.us/guide/bgc/pdf/bgc_usl_c_1.pdf
### Github Repo (private)

### Online materials
[2] https://omscs.gatech.edu/cs-8001-seminars

## What I'm doing next
