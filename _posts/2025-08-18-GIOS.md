---
title: CS 6200 - Graduate Introduction to Operating Systems
date: 2025-08-18 13:19:00 +0800
categories: [GaTech OMSCS, Operating Systems]
tags: [c, c++, powershell, linux, wsl]     # TAG names should always be lowercase
description: Overview & Projects from GIOS
---


# Welcome
#### Note
For all OMSCS courses - I will provide pseudocode and video links, but I need to keep code in a private repository to uphold the honor code. Descriptions, notes, etc are below. 

# Projects

## Setting up my test environment 
The first thing you do in GIOS is set up your test environment. There are a million different ways to do this, I settled on VS code and docker following the tutorial below: 
- [Set Up for Docker with VSCode and WSL2](https://docs.google.com/document/d/1-TLnnWRfcqFjuzlaAvsxXppVnlklKBb9FBv_stK86tg/edit?tab=t.0)


### VSCode and Docker 
GIOS repo: 
- https://github.gatech.edu/gios-fall-25/environment

#### Step 1
- Install Linux on Windows with WSL (for GIOSFA25 get UBUNTU 20.04)
- Install Docker Desktop and add GIOS image
- Resource: https://www.docker.com/ && 
https://learn.microsoft.com/en-us/windows/wsl/install
```powershell
wsl.exe --install Ubuntu-20.04
```
Notes:
1. Make sure you set your linux default WSL to the 20.04 ubuntu for GIOS (see Microsoft documentation)
2. Make sure you are on WSL 2 not 1 to avoid errors

#### Step 2
- Open WSL and get vscode on wsl
```bash
wsl
code .
```
Notes:
1. in VSCode get the Docker, Remote Development, and C/C++ extensions

#### Step 3
- Download all the absolutely necessary code provided in the GIOS repo in vscode (since it should have opened after it downloaded) or linux terminal 
Including: Add the course PPA, update the repos, install requirements (gcc should work after you've done this)

#### Step 4
- Add the tutorial's configure.yml file to a home folder you plan on using for the projects 
```yaml
name: cs6200-gios            # see Ref 1 below
services:
  cs6200-gios:               # see Ref 1 below
    image: gtomscs6200/fall25-environment:latest # note: set appropriately to current semester
    container_name: dev-env  # see Ref 1 below
    tty: true                # see Ref 2 below
    working_dir: /home/files
    restart: unless-stopped
    volumes:
      - .:/home/files:rw     # see Ref 3 below
```

- Ref 1: These names/labels can be set according to your preference

- Ref 2: https://stackoverflow.com/a/42597165

- Ref 3: general form is `<host-path>:<container-path>:rw`, where `.` here denotes the host-system 
- location in which `docker compose up -d` command is run on file `compose.yaml`, with
- corresponding bind mounting to container location `/home/files` as designated above. Note that you
- may designate `<container-path>` per your own preference. Suffix `:rw` denotes read & write modes.
- See https://docs.docker.com/compose/compose-file/ and https://docs.docker.com/compose/compose-file/compose-file-v3/#volumes for more details.

##### [Reference & Source for Step 4](https://docs.google.com/document/d/1-TLnnWRfcqFjuzlaAvsxXppVnlklKBb9FBv_stK86tg/edit?tab=t.0)
#### Step 5
Open the Dev Containers extension in VS Code. You should see cs6200-gios, and inside it, dev-env.
   
![image of docker in vscode](lorenzafriedrich.github.io\assets\img\img1.PNG "image of docker in vscode")

- If the dev environment is not running, right-click on dev-env and select Start.

- Once it’s running, right-click on dev-env again and select Attach Visual Studio Code to open the Docker container in VS Code.

You’ll know you’re inside the container if the remote connection status in the bottom left corner shows something like Container: gtomscs6200/fa25-environment.

#### Step 6
Open up a new terminal in your container in VSCode and run inotify
Resources:
- [Man Page](https://www.man7.org/linux/man-pages/man7/inotify.7.html)
- [inotify code](https://drive.google.com/file/d/1dMIPMESO3iK41j5fvkbTF4JVBU7XS0ej/view)

Make a new c file called inotify (or whatever you want), copy in the inotify code linked above and run the following

```bash
make inotify

./inotify . 
```
Output should look something like
```bash
root@54c5497edb9c:/home/files# ./inotify .
Press ENTER key to terminate.
Listening for events.
```
#### Step 7
Open up the split screen terminal windows and test out inotify
```bash
//on right side of the split terminal run the following tests:

ll //not one-one

cat inotify.c 
```
Output should look like this for >11
- LEFT
```bash
root@54c5497edb9c:/home/files# ./inotify .
Press ENTER key to terminate.
Listening for events.
IN_OPEN: ./ [directory]
IN_CLOSE_NOWRITE: ./ [directory]
IN_OPEN: ./ [directory]
IN_CLOSE_NOWRITE: ./ [directory]
```
- RIGHT
```bash
root@54c5497edb9c:/home/files# ll
total 56
drwxr-xr-x 6 1000 1000  4096 Aug 22 16:07 ./
drwxr-xr-x 1 root root  4096 Aug 22 15:25 ../
-rw-r--r-- 1 1000 1000   318 Aug 22 15:25 compose.yaml
-rwxr-xr-x 1 root root 17400 Aug 22 15:45 inotify*
-rw-r--r-- 1 root root  4677 Aug 22 15:44 inotify.c
drwxr-xr-x 3 1000 1000  4096 Aug 22 16:14 munit/
drwxr-xr-x 2 1000 1000  4096 Aug 22 15:21 p1/
drwxr-xr-x 2 1000 1000  4096 Aug 22 15:21 p3/
drwxr-xr-x 2 1000 1000  4096 Aug 22 15:21 p4/
```
AND this for >cat inotify.c
- LEFT
```bash
root@54c5497edb9c:/home/files# ./inotify .
Press ENTER key to terminate.
Listening for events.
IN_OPEN: ./ [directory]
IN_CLOSE_NOWRITE: ./ [directory]
IN_OPEN: ./ [directory]
IN_CLOSE_NOWRITE: ./ [directory]
IN_OPEN: ./ [directory]
IN_CLOSE_NOWRITE: ./ [directory]
IN_OPEN: ./ [directory]
IN_CLOSE_NOWRITE: ./ [directory]
IN_OPEN: ./ [directory]
IN_CLOSE_NOWRITE: ./ [directory]
IN_OPEN: ./ [directory]
IN_CLOSE_NOWRITE: ./ [directory]
IN_OPEN: ./inotify.c [file]
IN_CLOSE_NOWRITE: ./inotify.c [file]
```
- RIGHT

```bash
root@54c5497edb9c:/home/files# cat inotify.c
#include <errno.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/inotify.h>
#include <unistd.h>
#include <string.h>

/* Read all available inotify events from the file descriptor 'fd'.
  wd is the table of watch descriptors for the directories in argv.
  argc is the length of wd and argv.
  argv is the list of watched directories.
  Entry 0 of wd and argv is unused. */

static void
handle_events(int fd, int *wd, int argc, char* argv[])
{
    /* Some systems cannot read integer variables if they are not
      properly aligned. On other systems, incorrect alignment may
      decrease performance. Hence, the buffer used for reading from
      the inotify file descriptor should have the same alignment as
      struct inotify_event. */

    char buf[4096]
        __attribute__ ((aligned(__alignof__(struct inotify_event))));
    const struct inotify_event *event;
    ssize_t len;

    /* Loop while events can be read from inotify file descriptor. */

    for (;;) {

        /* Read some events. */

        len = read(fd, buf, sizeof(buf));
        if (len == -1 && errno != EAGAIN) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        /* If the nonblocking read() found no events to read, then
          it returns -1 with errno set to EAGAIN. In that case,
          we exit the loop. */

        if (len <= 0)
            break;

        /* Loop over all events in the buffer. */

        for (char *ptr = buf; ptr < buf + len;
                ptr += sizeof(struct inotify_event) + event->len) {

            event = (const struct inotify_event *) ptr;

            /* Print event type. */

            if (event->mask & IN_OPEN)
                printf("IN_OPEN: ");
            if (event->mask & IN_CLOSE_NOWRITE)
                printf("IN_CLOSE_NOWRITE: ");
            if (event->mask & IN_CLOSE_WRITE)
                printf("IN_CLOSE_WRITE: ");

            /* Print the name of the watched directory. */

            for (int i = 1; i < argc; ++i) {
                if (wd[i] == event->wd) {
                    printf("%s/", argv[i]);
                    break;
                }
            }

            /* Print the name of the file. */

            if (event->len)
                printf("%s", event->name);

            /* Print type of filesystem object. */

            if (event->mask & IN_ISDIR)
                printf(" [directory]\n");
            else
                printf(" [file]\n");
        }
    }
}

int
main(int argc, char* argv[])
{
    char buf;
    int fd, i, poll_num;
    int *wd;
    nfds_t nfds;
    struct pollfd fds[2];

    if (argc < 2) {
        printf("Usage: %s PATH [PATH ...]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    printf("Press ENTER key to terminate.\n");

    /* Create the file descriptor for accessing the inotify API. */

    fd = inotify_init1(IN_NONBLOCK);
    if (fd == -1) {
        perror("inotify_init1");
        exit(EXIT_FAILURE);
    }

    /* Allocate memory for watch descriptors. */

    wd = calloc(argc, sizeof(int));
    if (wd == NULL) {
        perror("calloc");
        exit(EXIT_FAILURE);
    }

    /* Mark directories for events
      - file was opened
      - file was closed */

    for (i = 1; i < argc; i++) {
        wd[i] = inotify_add_watch(fd, argv[i],
                                  IN_OPEN | IN_CLOSE);
        if (wd[i] == -1) {
            fprintf(stderr, "Cannot watch '%s': %s\n",
                    argv[i], strerror(errno));
            exit(EXIT_FAILURE);
        }
    }

    /* Prepare for polling. */

    nfds = 2;

    fds[0].fd = STDIN_FILENO;       /* Console input */
    fds[0].events = POLLIN;

    fds[1].fd = fd;                 /* Inotify input */
    fds[1].events = POLLIN;

    /* Wait for events and/or terminal input. */

    printf("Listening for events.\n");
    while (1) {
        poll_num = poll(fds, nfds, -1);
        if (poll_num == -1) {
            if (errno == EINTR)
                continue;
            perror("poll");
            exit(EXIT_FAILURE);
        }

        if (poll_num > 0) {

            if (fds[0].revents & POLLIN) {

                /* Console input is available. Empty stdin and quit. */

                while (read(STDIN_FILENO, &buf, 1) > 0 && buf != '\n')
                    continue;
                break;
            }

            if (fds[1].revents & POLLIN) {

                /* Inotify events are available. */

                handle_events(fd, wd, argc, argv);
            }
        }
    }

    printf("Listening for events stopped.\n");

    /* Close inotify file descriptor. */

    close(fd);

    free(wd);
    exit(EXIT_SUCCESS);
}
root@54c5497edb9c:/home/files# 
```

#### Other Unit Tests
```
git clone https://github.com/nemequ/munit.git

gcc -Wall example.c munit.c munit.h -o example

./example
```
Output should look like 
```bash
Running test suite with seed 0x5a13d21b...
/example/compare                     [ OK    ] [ 0.00006970 / 0.00000230 CPU ]
/example/rand                        [ OK    ] [ 0.00000620 / 0.00000560 CPU ]
/example/parameters                  
  foo=one, bar=red                   [ OK    ] [ 0.00000610 / 0.00000540 CPU ]
  foo=one, bar=green                 [ OK    ] [ 0.00000610 / 0.00000540 CPU ]
  foo=one, bar=blue                  [ OK    ] [ 0.00000600 / 0.00000540 CPU ]
  foo=two, bar=red                   [ OK    ] [ 0.00000600 / 0.00000550 CPU ]
  foo=two, bar=green                 [ OK    ] [ 0.00000600 / 0.00000540 CPU ]
  foo=two, bar=blue                  [ OK    ] [ 0.00000870 / 0.00000750 CPU ]
  foo=three, bar=red                 [ OK    ] [ 0.00000620 / 0.00000570 CPU ]
  foo=three, bar=green               [ OK    ] [ 0.00000640 / 0.00000570 CPU ]
  foo=three, bar=blue                [ OK    ] [ 0.00000600 / 0.00000540 CPU ]
11 of 11 (100%) tests successful, 0 (0%) test skipped.
```
#### Notes for me:
- project is held on ubuntu 20.04 callled 'gios'
```bash
gios@DESKTOP-QUQS18F://home/gios/projects$
```
## Overview - Sequence of Projects 
1. Threads
3. Concurrency
4. Synchronization

Projects will cover single-node OS mechanisms (inter-process communication, scheduling, etc) and multi-node OS mechanisms (remote procedure calls (RPC), etc) and experimental design and evaluation 
All programs are in C and Linux
## Project 1

### Warm Up 

## Project 3

## Project 4

# Exams

## Midterm Exam Prep

## Final Exam Prep

# Quizzes

# Lecture Notes
## P1L1 - Introduction to Operating Systems 
The course covers:
- what are operating systems
- why are operating systems needed
- how are operating systems designed and implemented? 

Course Topics include OS abstractions, mechanisms, and policies for
- processes and process management
- threads and concurrency
- resource management: scheduling, memory management
- OS services for communication and I/O
- OS support for distributed services
## P1L2 - Introduction to Operating Systems 
What is a Operating System? In simplest terms, it is a piece of software that abstracts and arbitrates the hardware of a system. 

An operating system is like a toy shop manager:

Toy Shop Manager
- Directs operational Resources by controlling use of employee time, parts, tools
- Enforces working policies - fairness safety, clean up
- Mitigates difficulty of complex tasks - simplifies operation and optimizes performance

Operating systems
- Directs operational Resources - controls use of CPU, memory, peripheral devices
- Enforces working policies - fair resouce access, limits to resource usage
- Mitigates difficulty of complex tasks - abstract hardware details (system calls)

Operating System Definition
![OS definition](lorenzafriedrich.github.io\assets\img\Posts\GIOS\whatisanOS.png "OS definition")
An operating system is a layer of systems software that:
- directly has priviledged access to the underlying hardware;
- hides the hardware complexity;
- manages hardware on behalf of one or more applications according to some predefined policies
- In addition, it ensures that applications are isolated and protected from one another 

Important definitions: abstraction versus arbitration, scheduler, device driver, file system, memory management, OS Design principals 

#### Operating systems Examples
Desktop (microsoft Windows, UNIX-based OS (including mac OS X (BSD), Linux)) and Embedded (Android, iOS, Symbian) are the focus of the class 

#### OS Elements
Abstractions (nouns):
- process, thread, file, socket, memory page

Mechanisms (verbs):
- create, schedule, open, write, allocate

Policies:
- least recently used (LRU), earliest deadline first (EDF)

#### Design Prinipals 
- Separation of mechanism & policy: implement flexible mechanisms to support many policies (e.g. LRU, LFU, random)
- Optimize for the common case: where will the OS be used? What will the user want to execute on that machine? What are the workload requirements? 

#### User/Kernel Protection Boundary 
![User/Kernel](lorenzafriedrich.github.io\assets\img\Posts\GIOS\P1L2Userkernelbundary.png "User/Kernal")

# Useful Resources 

## Textbooks and other reference materials:

- https://pages.cs.wisc.edu/~remzi/OSTEP/ Operating Systems: Three Easy Pieces

- chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://broman.dev/download/The%20Linux%20Programming%20Interface.pdf The Linux Programming Interface

- https://beej.us/guide/ 
Specifically - an introduction to socket programming:  
- https://beej.us/guide/bgnet0/

- https://www.kernel.org/doc/man-pages/ The Linux man-pages project


## C References:

- https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/pages/lecture-notes/

- https://learnxinyminutes.com/c/

- https://www.linkedin.com/learning/career-journey?initPlanV2=true&u=2163426

- http://goshdarnfunctionpointers.com/

- http://www.cprogramming.com/tutorial/function-pointers.html


Presentation on programming with C from Chris D. (with some updates from TAs)

Youtube of the Q&A C Video from Chris. D.

Harvard CS50 course on C and their reference site.

C/Standard Library docs

C, Pointers, and other lessons on C

Thread programming:

Posix Thread Programming tutorial

## Network programming resources:

https://beej.us/guide/bgnet/html/
https://www.codeproject.com/Articles/586000/Networking-and-Socket-programming-tutorial-in-C
http://www.binarytides.com/socket-programming-c-linux-tutorial/

## Debugging:


## some useful cheatsheets: 

Vim Cheat Sheet
TMUX Cheat Sheet
GIT Cheat Sheet
Linux source cross-references:

Linux Kernel Map
Linux source cross-reference
reference_material

# Past course resources
- https://github.gatech.edu/rdiaconescu3/6200_GIOS_flashcards/blob/main/GIOS_flashcards.apkg
- https://onedrive.live.com/?redeem=aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBbXBpTXN0VG5CRWpzUUtpTk8yRzdiR21PLWJyP2U9Y2R1SXRJ&cid=23119C53CB32626A&id=23119C53CB32626A%216274&parId=root&o=OneUp
- https://www.omscs-notes.com/operating-systems/midterm-exam-review-questions/
